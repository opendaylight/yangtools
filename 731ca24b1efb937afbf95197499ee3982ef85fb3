{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8da730f8_d66c6ea0",
        "filename": "codec/yang-data-codec-gson/src/main/java/org/opendaylight/yangtools/yang/data/codec/gson/JSONCodecFactory.java",
        "patchSetId": 15
      },
      "lineNbr": 120,
      "author": {
        "id": 649
      },
      "writtenOn": "2022-12-04T10:50:47Z",
      "side": 1,
      "message": "this is not appropriate -- see RFC7951.",
      "range": {
        "startLine": 120,
        "startChar": 40,
        "endLine": 120,
        "endChar": 45
      },
      "revId": "731ca24b1efb937afbf95197499ee3982ef85fb3",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c3d12d98_ecf43a34",
        "filename": "codec/yang-data-codec-gson/src/main/java/org/opendaylight/yangtools/yang/data/codec/gson/JSONCodecFactory.java",
        "patchSetId": 15
      },
      "lineNbr": 120,
      "author": {
        "id": 649
      },
      "writtenOn": "2022-12-05T15:36:41Z",
      "side": 1,
      "message": "nevermind, I misread it",
      "parentUuid": "8da730f8_d66c6ea0",
      "range": {
        "startLine": 120,
        "startChar": 40,
        "endLine": 120,
        "endChar": 45
      },
      "revId": "731ca24b1efb937afbf95197499ee3982ef85fb3",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e0f469a5_4d2d8317",
        "filename": "data/yang-data-impl/src/main/java/org/opendaylight/yangtools/yang/data/impl/codec/BitsHexStringCodec.java",
        "patchSetId": 15
      },
      "lineNbr": 30,
      "author": {
        "id": 649
      },
      "writtenOn": "2022-12-05T15:41:49Z",
      "side": 1,
      "message": "I really would prefer we would use a dedicated type for this. I mean yes, String works, but then we have to parse it.\n\nHaving an interface would allow us to have actual specializations, i.e. if the number of bits is less than 64, use a plain long, if it is larger, use byte[] plus an ImmutableOffsetMap, etc.\n\nIt also would allow us to retain a .toString() which is friendly, and we also could have a friendly .toSet() which would return a Set\u003cString\u003e backed by whatever the internal representation is.",
      "range": {
        "startLine": 30,
        "startChar": 65,
        "endLine": 30,
        "endChar": 71
      },
      "revId": "731ca24b1efb937afbf95197499ee3982ef85fb3",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "51352a5b_ebc30928",
        "filename": "data/yang-data-impl/src/main/java/org/opendaylight/yangtools/yang/data/impl/codec/BitsHexStringCodec.java",
        "patchSetId": 15
      },
      "lineNbr": 30,
      "author": {
        "id": 8894
      },
      "writtenOn": "2022-12-12T15:44:10Z",
      "side": 1,
      "message": "dedicated type is introduced in alt change https://git.opendaylight.org/gerrit/c/yangtools/+/103659\n\nnotes: \n\na) neither integer nor long nor byte[] provide friendly interface to bit state,\nall of these require extra logic, there is no any reason to use these types \nbecause existing type BitSet already covers any length.\n\nB) necessity to include bit names to offset map into an object (to serve \n\"friendly\" api) does not help to minimize resource usage; it contradicts\nthe goal of the task, unless configuration part (bit name to offset map) \nis never persisted, then bits type definition will be always required to \nrestore Bits object out of backing data",
      "parentUuid": "e0f469a5_4d2d8317",
      "range": {
        "startLine": 30,
        "startChar": 65,
        "endLine": 30,
        "endChar": 71
      },
      "revId": "731ca24b1efb937afbf95197499ee3982ef85fb3",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4f5f260a_07cebe42",
        "filename": "data/yang-data-impl/src/main/java/org/opendaylight/yangtools/yang/data/impl/codec/BitsHexStringCodec.java",
        "patchSetId": 15
      },
      "lineNbr": 43,
      "author": {
        "id": 8324
      },
      "writtenOn": "2022-12-02T08:35:14Z",
      "side": 1,
      "message": "Whats the reason behind using AttomicInteger here, if the Bit object contains the position already.",
      "revId": "731ca24b1efb937afbf95197499ee3982ef85fb3",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "905ed9af_e042cc5d",
        "filename": "data/yang-data-impl/src/main/java/org/opendaylight/yangtools/yang/data/impl/codec/BitsHexStringCodec.java",
        "patchSetId": 15
      },
      "lineNbr": 43,
      "author": {
        "id": 8894
      },
      "writtenOn": "2022-12-02T10:23:09Z",
      "side": 1,
      "message": "https://www.rfc-editor.org/rfc/rfc7950#section-9.7.4.2\nthe position value can be up to 4_294_967_295\nit transfers into max storage value up to ~ 512 Mb,\nrecalculating bit positions from expected to \nactual helps saving space (no wasted bits)",
      "parentUuid": "4f5f260a_07cebe42",
      "revId": "731ca24b1efb937afbf95197499ee3982ef85fb3",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93413077_b517b4bf",
        "filename": "data/yang-data-impl/src/main/java/org/opendaylight/yangtools/yang/data/impl/codec/BitsHexStringCodec.java",
        "patchSetId": 15
      },
      "lineNbr": 54,
      "author": {
        "id": 649
      },
      "writtenOn": "2022-12-05T15:36:24Z",
      "side": 1,
      "message": "@NonNull is a TYPE_USE annotation, so it is \u0027final @NonNull String\u0027 -- otherwise Sonar will not like it",
      "range": {
        "startLine": 54,
        "startChar": 46,
        "endLine": 54,
        "endChar": 54
      },
      "revId": "731ca24b1efb937afbf95197499ee3982ef85fb3",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    }
  ]
}